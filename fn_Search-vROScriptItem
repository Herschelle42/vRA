function Search-vROScriptItem
{
<#
.Synopsis
   Search the Script Item of an Action or Workflow using regex or a simple text search
.DESCRIPTION
   Retrieves one or more vRO(vCO) Actions that meet the criteria specified by the parameters.
.PARAMETER Protocol
    The protocol to use to connect to vRO. Valid values are http/https. Default is https.
.PARAMETER ComputerName
   The FQDN, IP address of the vRO server
.PARAMETER Port
    The port to connect to vRO. For example 8281. Default is none.
.PARAMETER Username
    The username to connect to vRO
.PARAMETER Password
    The password to connect to vRO
.PARAMETER Credential
    The powershell Credential object to use to connect to vRO
.PARAMETER Type
    The vRO object type to search. Valid values are action\workflow\all. Mandatory.
.PARAMETER Pattern
    The text string or regex pattern to search for.
.PARAMETER Regex
    Switch indicating whether the Pattern is a regex. Default is false.
    Uses Select-String -Pattern parameter if enabled. Else uses the -SimpleMatch for non-regex string searching.
.EXAMPLE
    $pattern = ".local"
    $credential = Get-Credential -Username "vro-user" -Message "Please enter vRO Username and password"
    [array]$result = Search-vROScriptItem -ComputerName "vro.corp.local" -Credential $credential -Type action -Pattern $pattern
    $result[0]

    Type   : Action
    Name   : createEventDefinition
    Path   : com.vmware.library.vcac/createEventDefinition
    Id     : 7b359d5f-7460-424b-b811-bb9a3c9c6aba
    Script : @{LineNumber=18; Line=// Ugly work around for having an entity created with a CreatedDateTime of type org.joda.time.LocalDateTime (bug 1033984)}

    Returns the straight string match ".local"
.EXAMPLE
    $pattern = ".local"
    $credential = Get-Credential -Username "vro-user" -Message "Please enter vRO Username and password"
    [array]$result = Search-vROScriptItem -ComputerName "vro.corp.local" -Credential $credential -Type action -Pattern $pattern
    $result[0]
    
    Type   : Action
    Name   : createAzureConfigurations
    Path   : com.vmware.vra.endpoint.azure.configuration/createAzureConfigurations
    Id     : 0fbf7c8e-573a-4ed2-b90c-c7feb70a7e71
    Script : {@{LineNumber=28; Line=        A_Standard_A0:  "CPU Cores (1), Memory:GiB (0.768), Local HDD:GiB (20), Max data disks(1), Max data disk throughput:IOPS (1x500), Max NICs/Network bandwidth (1/low)",}, @{LineNumber=29; Line=        A_Standard_A1:  "CPU Cores (1), Memory:GiB (1.75), Local HDD:GiB (70), Max data disks(2), Max data disk throughput:IOPS (2x500), Max NICs/Network bandwidth (1/moderate)",}, @{LineNumber=30; Line=        A_Standard_A2:  "CPU Cores (2), Memory:GiB (3.5), Local HDD:GiB (135), Max data disks(4), Max data disk throughput:IOPS (4x500), Max NICs/Network bandwidth (1/moderate)",}, @{LineNumber=31; Line=        A_Standard_A3:  "CPU Cores (4), Memory:GiB (7), Local HDD:GiB (285), Max data disks(8), Max data disk throughput:IOPS (8x500), Max NICs/Network bandwidth (2/high)",}...}

    Same query with the -Regex parameter added, returns line items where the dot (.) is treated as a regex item indicating "any" character.

.INPUTS
   [String]
   [Int]
   [SecureString]
   [Management.Automation.PSCredential]
   [Switch]
.OUTPUTS
   [PSObject]
.NOTES
   Author:  Clint Fritz
   Enhancments ideas: 
   - Add Case sensitivity searching

#>
[CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$false)]
        [ValidateSet("https","http")]
        [string]$Protocol="https",

        [Parameter(Mandatory=$true)]
        [Alias("Server","IPAddress","FQDN")]
        [string]$ComputerName,

        [Parameter(Mandatory=$false)]
        [ValidatePattern("^[1-9][0-9]{0,4}$")]
        [int]$Port,

        [Parameter(Mandatory=$true,ParameterSetName="Username")]
        [string]$Username,

        [Parameter(Mandatory=$true,ParameterSetName="Username")]
        [SecureString]$Password,

        [Parameter(Mandatory=$true,ParameterSetName="Credential")]
        [ValidateNotNullOrEmpty()]
        [Management.Automation.PSCredential]$Credential,

        [Parameter(Mandatory=$true)]
        [ValidateSet("workflow","action","all")]
        [string]$Type,

        [Parameter(Mandatory=$true)]
        [String]$Pattern,

        [Parameter(Mandatory=$false)]
        [Switch]$Regex=$false
        
    )

    Begin
    {
        [string]$method="GET"

        Write-Verbose "[INFO] Protocol: $($Protocol)"
        Write-Verbose "[INFO] ComputerName: $($ComputerName)"
        Write-Verbose "[INFO] Port: $($Port)"

        #--- extract username and password from credential
        if ($PSBoundParameters.ContainsKey("Credential")){
            Write-Verbose "[INFO] Credential: $($Credential | Out-String)"
            $Username = $Credential.UserName
            $UnsecurePassword = $Credential.GetNetworkCredential().Password
        }
        
        if ($PSBoundParameters.ContainsKey("Password")){
            Write-Verbose "[INFO] Username: $($Username)"
            #Write-Verbose "[INFO] Password: $($Password)"
            $UnsecurePassword = (New-Object System.Management.Automation.PSCredential(“username”, $Password)).GetNetworkCredential().Password
        }

        Write-Verbose "[INFO] Type: $($Type)"

        #If not a regex pattern, then escape it so that regex characters are escaped.
        #for example fullstop . in regex is any character. espacing it means to search for the fullstop character itself.
        <#
        if (-not $regex)
        {
            $Pattern = [regex]::Escape($Pattern)
        }
        No longer required as using the Select-String and parameters rather than -match
        #>

        Write-Verbose "[INFO] Pattern: $($Pattern)"
        Write-Verbose "[INFO] Regex: $($Regex)"
        
        #--- Create authorization headers
        #Write-Verbose "insecure: $($UnsecurePassword)"
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $Username,$UnsecurePassword)))
        $headers = @{"Authorization"=("Basic {0}" -f $base64AuthInfo)}
        #$headers = @{"Content-Type"="application/json"; "Accept"="application/json"; "Authorization"=("Basic {0}" -f $base64AuthInfo)}

        Write-Verbose "[INFO] Headers: $($headers | Out-String)"

        #If a port is defined, updated the server uri.
        $serverUri = $null
        if($Port) {
          $serverUri = "$($protocol)://$($ComputerName):$($Port)"
        } else {
          $serverUri = "$($protocol)://$($ComputerName)"
        }
        $apiUri = "$($serverUri)/vco/api"
        Write-Verbose "[INFO] Server API Uri: $($apiUri)"

        <#
        vRO 7.x requires tls 1.2 to work, otherwise will receive the error:
        Invoke-RestMethod : The underlying connection was closed: An unexpected error occurred on a send.
        when attempting to do Invoke-restmethod
        #>
        if (-not ("Tls12" -in  (([System.Net.ServicePointManager]::SecurityProtocol).ToString() -split ", ")))
        {
            Write-Verbose "[INFO] Adding Tls 1.2 to security protocol"
            [System.Net.ServicePointManager]::SecurityProtocol += [System.Net.SecurityProtocolType]::Tls12
        }#end if tls12

        function intGet-ActionScripts
        {
            Write-Verbose "[INFO] Get Actions"

            $uri = "$($apiUri)/actions"
            $result = $null
            $result = Invoke-RestMethod -Method $method -UseBasicParsing -Uri $uri -Headers $headers

            Write-Verbose "[INFO] Create a new flat custom object for easier manipulation"
            $item = $null
            $itemList = foreach ($item in $result.link){
    
                $hash = [ordered]@{}
                foreach ($attrib in $item.attributes)
                {
                    $hash.$($attrib.name) = $($attrib.value)
                }#end foreach attrib
                $hash.href = $item.href
                $hash.rel = $item.rel
				$hash.Script = $null
                $object = new-object PSObject -property $hash 
                $object
  
            }#end foreach action

            Write-Verbose "[INFO] Get each script element"
            $item = $null
            foreach ($item in $itemList)
            {
                Write-Verbose "[INFO] Action: $($item.name)"
                try {
                    $result = $null
                    $result = Invoke-RestMethod -Method $method -UseBasicParsing -Uri "$($item.href)" -Headers $headers
                } catch [System.Net.WebException] {
        
                    if ($($_.Exception.Message) -eq "The remote server returned an error: (400) Bad Request." )
                    {
                        Write-Verbose "[ERROR] !!! $($_.Exception.Message)"
                        <# Undecided how we surface this up.
                        $hash=[ordered]@{}
                        $hash.Name = $item.name
                        $hash.Path = $item.globalTags.Replace(" ","\")
                        $hash.ItemName = "ERROR: $($_.Exception.Message)"
                        $hash.Script = $null
                        $object = New-Object -TypeName PSObject -Property $hash
                        $object
                        #>
                    } else {
                        throw
                    }

                } catch {
                    throw
                }#end try catch

                #Is this a regex search or a simple text search.
                if ($regex) 
                {
                    Write-Verbose "[INFO] Regex search"

                    if ($linesFound = $result.script.Split("`r`n") | Select-String -Pattern $pattern | Select LineNumber, Line)
                    {
                        Write-Verbose "[INFO] Lines found: $($linesFound.count)"
                        $hash=[ordered]@{}
                        $hash.Type="Action"
                        $hash.Name = $item.name
                        $hash.Path = $item.fqn
                        $hash.Id = $item.id
                        $hash.Script = $linesFound
                        $object = New-Object -TypeName PSObject -Property $hash
                        $object
                    }#end if lines pattern (regex)

                } else {
                    Write-Verbose "[INFO] Simple search"

                    if ($linesFound = $result.script.Split("`r`n") | Select-String -SimpleMatch $pattern | Select LineNumber, Line)
                    {
                        Write-Verbose "[INFO] Lines found: $($linesFound.count)"
                        $hash=[ordered]@{}
                        $hash.Type="Action"
                        $hash.Name = $item.name
                        $hash.Path = $item.fqn
                        $hash.Id = $item.id
                        $hash.Script = $linesFound
                        $object = New-Object -TypeName PSObject -Property $hash
                        $object
                    }#end if lines simplematch

                }#end if regex

            }#end foreach item

        }#end function intGet-ActionScripts

        function intGet-WorkflowScripts
        {
            Write-Verbose "[INFO] Get Workflows"

            $uri = "$($apiUri)/workflows?maxResult=2147483647&startIndex=0&queryCount=false"
            $result = $null
            $result = Invoke-RestMethod -Method $method -UseBasicParsing -Uri $uri -Headers $headers

            Write-Verbose "[INFO] Create a new flat custom object for easier manipulation"
            $item = $null
            $itemList = foreach ($item in $result.link){
    
                $hash = [ordered]@{}
                foreach ($attrib in $item.attributes)
                {
                    $hash.$($attrib.name) = $($attrib.value)
                }#end foreach attrib
                $hash.href = $item.href
                $hash.rel = $item.rel
                $hash.Script = $null
                $object = new-object PSObject -property $hash 
                $object
  
            }#end foreach action

            Write-Verbose "[INFO] Get each script element"
            $item = $null
            foreach ($item in $itemList)
            {
                Write-Verbose "[INFO] Workflow: $($item.name)"
                try {
                    $wfContent = $null
                    $wfContent = Invoke-RestMethod -Method $method -UseBasicParsing -Uri "$($item.href)content/" -Headers $headers
                } catch [System.Net.WebException] {
        
                    if ($($_.Exception.Message) -eq "The remote server returned an error: (400) Bad Request." )
                    {
                        Write-Verbose "[ERROR] !!! $($_.Exception.Message)"
                        <# Undecided how we surface this up.
                        $hash=[ordered]@{}
                        $hash.Name = $item.name
                        $hash.Path = $item.globalTags.Replace(" ","\")
                        $hash.ItemName = "ERROR: $($_.Exception.Message)"
                        $hash.Script = $null
                        $object = New-Object -TypeName PSObject -Property $hash
                        $object
                        #>
                    } else {
                        throw
                    }

                } catch {
                    throw
                }#end try catch

                foreach ($contentItem in $wfContent.'workflow-item' | ? { $_.Script } )
                {
                    Write-Verbose "[INFO] ItemName: $($contentItem.'display-name')"
        
                    #Is this a regex search or a simple text search.
                    if ($regex) 
                    {
                        Write-Verbose "[INFO] Regex search"

                        if ($linesFound = $contentItem.script.value.Split("`r`n") | Select-String -Pattern $pattern | Select LineNumber, Line)
                        {
                            Write-Verbose "[INFO] Lines found: $($linesFound.count)"
                            $hash=[ordered]@{}
                            $hash.Type="Workflow-$($contentItem.type)"
                            $hash.Name = $contentItem.'display-name'
                            $hash.Path = "$($item.globalTags.Replace(' ','\'))\$($item.name)"
                            $hash.Id = $item.Id
                            $hash.Script = $linesFound
                            $object = New-Object -TypeName PSObject -Property $hash
                            $object
                        }#end if lines pattern (regex)

                    } else {
                        Write-Verbose "[INFO] Simple search"

                        if ($linesFound = $contentItem.script.value.Split("`r`n") | Select-String -SimpleMatch $pattern | Select LineNumber, Line)
                        {
                            Write-Verbose "[INFO] Lines found: $($linesFound.count)"
                            $hash=[ordered]@{}
                            $hash.Type="Workflow-$($contentItem.type)"
                            $hash.Name = $contentItem.'display-name'
                            $hash.Path = "$($item.globalTags.Replace(' ','\'))\$($item.name)"
                            $hash.Id = $item.Id
                            $hash.Script = $linesFound
                            $object = New-Object -TypeName PSObject -Property $hash
                            $object
                        }#end if lines simplematch

                    }#end if regex
                    
                }#end foreach contentItem

            }#end foreach item

        }#end function intGet-WorkflowScripts

    }#end Begin block

    Process
    {
        #--- Search Actions ---------------------------------------------------
        if ($Type -eq "action")
        {
            intGet-ActionScripts
        }#end if Type action

        #--- Search Workflows -------------------------------------------------
        if ($Type -eq "workflow")
        {
            intGet-WorkflowScripts
        }#end if type workflow

        #--- Search both workflows and actions --------------------------------
        if ($Type -eq "all")
        {
            intGet-ActionScripts
            intGet-WorkflowScripts
        }#end if type workflow
        
    }#end Process block

    End
    {
    }#end End block

}#end Function
